#!/usr/bin/env python
# Dependency Tracker for C++ source tree
# Warning: This program do not understand any preprocessors and macros.
# And this program cannot track the dependendy if the header's name and source's name are different.
# (net_util.h <-\-> net_util_posix.cc)
#
# You may use `exclude` option to leave out unwanted dependency.
from __future__ import print_function

import os
import datetime
import argparse
import collections
from pprint import pprint


class DependencyTree(object):
    def __init__(self, excludes, incdirs, exts, debug=False):
        self.incdirs = (["."] + incdirs) if incdirs else ["."]
        self.excludes = set(excludes) if excludes else set()
        self.excludes_used = set()
        self.files_not_found = set()
        self.debug = debug
        self.wherefrom = {}
        self.depmap = {}
        self.exts = exts

    def scan_from(self, target):
        exts = self.exts
        depmap = self.depmap
        q = []
        vis = set()

        def enq(new, now):
            if not new:
                if self.debug:
                    print("invalid file in q from " + now)

            if not os.path.exists(new):
                tmp = new
                new = self.realpath(new, now)
                if not new:
                    self.files_not_found.add(tmp)
                    if self.debug:
                        print("resolve to invalid file: " + tmp + " from " + now)
                    return
    
            if new in self.excludes:
                self.excludes_used.add(new)
                return

            if new not in vis:
                vis.add(new)
                q.append(new)
                depmap[new] = []
                self.wherefrom[new] = now

        enq(target, None)

        while q:
            now = q.pop(0)

            if not now:
                if self.debug:
                    raise IOError("invalid file in queue")

            if self.debug:
                n = now
                print("  [ ", end=" ")
                while n:
                    print(n, " => ", end=" ")
                    n = self.wherefrom[n]
                print(" ]")

            for ext in exts:
                if now.endswith(".h") and os.path.exists(now[:-2] + ext):
                    enq(now[:-2] + ext, now)
                    depmap[now].append(now[:-2] + ext)

            for dependency in self.parse_cc(now):
                enq(dependency, now)
                # print now, dependency
                depmap[now].append(dependency)

        if len(self.files_not_found) > 0:
            print("these files not found:")
            pprint(self.files_not_found)

        return depmap

    def find_chromium_root(self):
        for d in self.incdirs:
            if 'chromium' in d:
                return d
        return None

    def write_feature_header(self, path2write, pp_symbol):
        f = open(path2write, "w")
        f.write("#pragma once" + os.linesep)
        f.write("#define " + pp_symbol + os.linesep)
        f.write("#include \"interop/compile_flags.h\"" + os.linesep)
        f.write("#undef " + pp_symbol + os.linesep)
        f.write("#include \"build/buildflag.h\"" + os.linesep)
        f.close()
        return path2write

    def write_build_date_header(self, path2write):
        f = open(path2write, "w")
        build_date = '{:%b %d %Y %H:%M:%S}'.format(datetime.datetime.utcnow())
        output = ('// Generated by //tools/inject.py\n'
           '#ifndef BUILD_DATE\n'
           '#define BUILD_DATE "{}"\n'
           '#endif // BUILD_DATE\n'.format(build_date))
        f.write(output)
        f.close()
        return path2write

    def write_effective_tld_cc(self, path2write):
        src = path2write.replace("-inc.cc", ".gperf")
        os.system("python ./ext/chromium/net/tools/dafsa/make_dafsa.py {} {}".format(src, path2write))
        return path2write

    def write_log_list_cc(self, path2write):
        src = path2write.replace("-inc.cc", ".json")
        os.system("python ./ext/chromium/net/tools/ct_log_list/make_ct_known_logs_list.py {} {}".format(src, path2write))
        return path2write

    def make_pp_symbol(self, now):
        return "_".join(os.path.dirname(now).split(os.sep)).upper() + "_COMPILE_FLAGS"

    def rescue_file_missing(self, non_real_path, imported_from_rpath):
        if not os.path.dirname(non_real_path):
            rescue_path = os.path.dirname(imported_from_rpath) + "/" + non_real_path
            if os.path.exists(rescue_path):
                return rescue_path
        if non_real_path.endswith("features.h"):
            root = self.find_chromium_root()
            return self.write_feature_header(os.path.join(root, non_real_path), self.make_pp_symbol(non_real_path))
        elif "debugging_flags.h" in non_real_path:
            root = self.find_chromium_root()
            return self.write_feature_header(os.path.join(root, non_real_path), "BASE_DEBUG")
        elif "generated_build_date.h" in non_real_path:
            root = self.find_chromium_root()
            return self.write_build_date_header(os.path.join(root, non_real_path))
        elif "effective_tld_names" in non_real_path:
            root = self.find_chromium_root()
            return self.write_effective_tld_cc(os.path.join(root, non_real_path))            
        elif "certificate_transparency/log_list" in non_real_path:
            root = self.find_chromium_root()
            return self.write_log_list_cc(os.path.join(root, non_real_path))                        
        else:
            return None

    def realpath(self, path, imported_from_rpath):
        for d in self.incdirs:
            rpath = os.path.join(d, path)
            if os.path.exists(rpath):
                return rpath 
        return self.rescue_file_missing(path, imported_from_rpath)

    def parse_cc(self, source):
        r = []
        f = None
        try:
            f = open(source, "r")
            for line in f:
                line = line.strip()
                if line.startswith("#include") and '"' in line:
                    fname = line.split('"')[1]
                    rfname = self.realpath(fname, source)
                    if not rfname:
                        if self.debug:
                            print("rfname not found:" + fname)
                        self.files_not_found.add(fname)
                        continue
                    r.append(rfname)
        finally:
            if f:
                f.close
        return r

    def traverse(self, lb):
        for k in self.depmap.keys():
            lb(k)


def load_exclude_file(excludes, file):
    if not excludes:
        excludes = set()

    with open(file, "r") as f:
        for line in f:
            l = line.strip()
            if l.startswith("#"):
                continue
            elif len(l) <= 0:
                continue
            else:
                excludes.add(l)

    if len(excludes) <= 0:
        raise IOError("invalid exclude file")

    return excludes

class GenListFileVisitor(object):
    def __init__(self):
        self.categorizer = collections.OrderedDict([
            (lambda f: f.endswith(".mm"), "mac"), 
            (lambda f: f.endswith("_mac.cc"), "mac"),
            (lambda f: f.endswith(".cc") and ("/mac/" in f), "mac"), 


            (lambda f: f.endswith("_posix.cc"), "posix"), 

            (lambda f: f.endswith("_linux.cc"), "linux"), 

            (lambda f: f.endswith("_fuchsia.cc"), "fuchsia"), 
            (lambda f: f.endswith(".cc") and ("/fuchsia/" in f), "fuchsia"), 

            (lambda f: f.endswith("_win.cc"), "win"), 
            (lambda f: f.endswith(".cc") and ("/win/" in f), "win"), 
            (lambda f: f.endswith(".cc") and ("winsock" in f), "win"), 

            (lambda f: f.endswith("_android.cc"), "android"),
            (lambda f: f.endswith(".cc") and ("/android/" in f), "android"), 

            (lambda f: f.endswith("_aix.cc"), "aix"),
            (lambda f: f.endswith(".cc") and ("/aix/" in f), "aix"), 

            (lambda f: f.endswith("_glib.cc"), "glib"),
            (lambda f: f.endswith(".cc") and ("/glib/" in f), "glib"), 

            (lambda f: f.endswith(".cpp"), "common"), 
            (lambda f: f.endswith(".cc"), "common"), 
        ])
        self.lists = {}
        for k in self.categorizer.keys():
            t = self.categorizer[k]
            self.lists[t] = set()
            
    def visit(self, file):
        for k in self.categorizer.keys():
            t = self.categorizer[k]
            #print("k = " + k + " t = " + t + " file = " + file)
            if k(file):
                self.lists[t].add(file)
                return

    def put_to(self, outdir):
        for t in self.lists.keys():
            with open(os.path.join(outdir, t + ".cmake"), "w") as f:
                ls = sorted(self.lists[t])
                text = "set(" + t + "_src" + os.linesep
                for l in ls:
                    text += ("\t" + l + os.linesep)
                text += ")"
                f.write(text)

class CopyFilesVisitor(object):
    def visit(self, file):


def main():
    parser = argparse.ArgumentParser(description="C++ Dependency Tracker for chromium")
    parser.add_argument("srcroot", type=str)
    parser.add_argument("--exclude", action="append")
    parser.add_argument("--exclude_file", type=str)
    parser.add_argument("--action", type=str)
    parser.add_argument("--debug", action="store_true")
    parser.add_argument("--dir", action="append")
    parser.add_argument("--outdir", type=str)

    args = parser.parse_args()
    if args.exclude_file: 
        args.exclude = load_exclude_file(args.exclude, args.exclude_file)

    exts = [".mm", "_posix.cc", "_linux.cc", "_win.cc", "_mac.cc", ".cpp", ".cc", "common"]
    tree = DependencyTree(args.exclude, args.dir, exts, args.debug)
    tree.scan_from(args.srcroot)

    visitor = TreeVisitor(categorizer)
    tree.traverse(visitor.visit)
    visitor.put_to(args.outdir)



if __name__ == "__main__":
    main()
